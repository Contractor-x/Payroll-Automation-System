from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBearer
from sqlalchemy.orm import Session
from datetime import datetime
from typing import Optional
from pydantic import BaseModel
import secrets
import string

from backend.database import get_db, User, AuditLog
from backend.auth.security import hash_password, verify_password, validate_password_strength
from backend.auth.two_factor import setup_two_factor_auth, verify_2fa_code
from backend.auth.middleware import (
    create_access_token, create_temp_token, verify_token,
    create_login_audit_log, increment_failed_attempts, reset_failed_attempts,
    is_account_locked, get_time_until_unlock
)

router = APIRouter()
security = HTTPBearer()


class LoginRequest(BaseModel):
    username: str
    password: str


class LoginResponse(BaseModel):
    message: str
    requires_2fa: bool
    temp_token: Optional[str] = None


class TwoFactorVerifyRequest(BaseModel):
    temp_token: str
    totp_code: str


class TwoFactorVerifyResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"
    expires_in: int = 1800  # 30 minutes


class CreateUserRequest(BaseModel):
    username: str
    email: str
    password: str


class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    is_active: bool
    has_2fa: bool
    created_at: datetime


@router.post("/login", response_model=LoginResponse)
async def login(login_data: LoginRequest, db: Session = Depends(get_db)):
    """
    Authenticate user with username and password
    Returns temporary token if 2FA is required
    """
    # Find user by username
    user = db.query(User).filter(User.username == login_data.username).first()
    
    if not user:
        # Don't reveal if user exists or not (security best practice)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    # Check if account is locked
    if is_account_locked(user):
        unlock_time = get_time_until_unlock(user)
        if unlock_time and unlock_time > 0:
            raise HTTPException(
                status_code=status.HTTP_423_LOCKED,
                detail=f"Account locked. Try again in {unlock_time} seconds"
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_423_LOCKED,
                detail="Account locked. Try again shortly"
            )
    
    # Verify password
    if not verify_password(login_data.password, user.password_hash, user.salt):
        increment_failed_attempts(db, user.username)
        
        # Create audit log for failed login
        create_login_audit_log(
            db, user, action="failed_login",
            details=f"Failed login attempt for user {user.username}"
        )
        
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid credentials"
        )
    
    # Check if user has 2FA enabled
    if user.totp_secret:
        # Create temporary token for 2FA verification
        temp_token_data = {
            "user_id": user.id,
            "username": user.username,
            "temp_purpose": "2fa_verification"
        }
        temp_token = create_temp_token(temp_token_data, expires_minutes=10)
        
        return LoginResponse(
            message="2FA verification required",
            requires_2fa=True,
            temp_token=temp_token
        )
    else:
        # No 2FA, create access token directly
        access_token_data = {
            "user_id": user.id,
            "username": user.username
        }
        access_token = create_access_token(access_token_data)
        
        # Reset failed attempts and update last login
        reset_failed_attempts(db, user.username)
        
        # Create audit log for successful login
        create_login_audit_log(
            db, user, action="login",
            details=f"Successful login for user {user.username}"
        )
        
        return LoginResponse(
            message="Login successful",
            requires_2fa=False
        )


@router.post("/verify-2fa", response_model=TwoFactorVerifyResponse)
async def verify_2fa(verify_data: TwoFactorVerifyRequest, db: Session = Depends(get_db)):
    """
    Verify 2FA code and return access token
    """
    try:
        # Verify temporary token
        token_data = verify_token(verify_data.temp_token, "temp")
        
        if token_data.user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid temporary token"
            )
        
        # Get user
        user = db.query(User).filter(User.id == token_data.user_id).first()
        if not user or not user.totp_secret:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid user or 2FA not configured"
            )
        
        # Verify TOTP code
        if not verify_2fa_code(user.totp_secret, verify_data.totp_code):
            # Create audit log for failed 2FA
            create_login_audit_log(
                db, user, action="failed_2fa",
                details=f"Failed 2FA verification for user {user.username}"
            )
            
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid 2FA code"
            )
        
        # Create access token
        access_token_data = {
            "user_id": user.id,
            "username": user.username
        }
        access_token = create_access_token(access_token_data)
        
        # Reset failed attempts and update last login
        reset_failed_attempts(db, user.username)
        
        # Create audit log for successful 2FA login
        create_login_audit_log(
            db, user, action="login_2fa",
            details=f"Successful 2FA login for user {user.username}"
        )
        
        return TwoFactorVerifyResponse(
            access_token=access_token,
            expires_in=1800  # 30 minutes
        )
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Internal server error during 2FA verification"
        )


# Import get_current_user (we need this at the end to avoid circular import)
from backend.auth.middleware import get_current_user


@router.post("/logout")
async def logout(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """
    Logout user (invalidate session)
    """
    # Create audit log for logout
    create_login_audit_log(
        db, current_user, action="logout",
        details=f"User {current_user.username} logged out"
    )

    # Note: JWT tokens are stateless, so we can't truly "invalidate" them
    # In production, you might want to maintain a blacklist of revoked tokens

    return {"message": "Successfully logged out"}


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user: User = Depends(get_current_user)):
    """
    Get current user information
    """
    return UserResponse(
        id=current_user.id,
        username=current_user.username,
        email=current_user.email,
        is_active=current_user.is_active,
        has_2fa=bool(current_user.totp_secret),
        created_at=current_user.created_at
    )


@router.post("/setup-2fa")
async def setup_2fa(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """
    Setup 2FA for the current user
    """
    if current_user.totp_secret:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="2FA is already configured for this user"
        )

    # Generate 2FA setup data
    setup_data = setup_two_factor_auth(current_user.username)

    # Save TOTP secret to user
    current_user.totp_secret = setup_data["secret"]
    db.commit()

    # Create audit log
    create_login_audit_log(
        db, current_user, action="setup_2fa",
        details=f"2FA setup initiated for user {current_user.username}"
    )

    return {
        "secret": setup_data["secret"],
        "qr_code": setup_data["qr_code"],
        "auth_uri": setup_data["auth_uri"],
        "backup_codes": setup_data["backup_codes"],
        "message": "Scan the QR code with Google Authenticator and save backup codes securely"
    }


@router.post("/disable-2fa")
async def disable_2fa(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """
    Disable 2FA for the current user
    """
    if not current_user.totp_secret:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="2FA is not configured for this user"
        )

    # Remove TOTP secret
    current_user.totp_secret = None
    db.commit()

    # Create audit log
    create_login_audit_log(
        db, current_user, action="disable_2fa",
        details=f"2FA disabled for user {current_user.username}"
    )

    return {"message": "2FA has been disabled"}


@router.post("/change-password")
async def change_password(
    current_password: str,
    new_password: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Change user password
    """
    # Verify current password
    if not verify_password(current_password, current_user.password_hash, current_user.salt):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Current password is incorrect"
        )

    # Validate new password strength
    is_valid, issues = validate_password_strength(new_password)
    if not is_valid:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Password validation failed: {'; '.join(issues)}"
        )

    # Hash new password
    new_hash, new_salt = hash_password(new_password)

    # Update password
    current_user.password_hash = new_hash
    current_user.salt = new_salt
    db.commit()

    # Create audit log
    create_login_audit_log(
        db, current_user, action="password_change",
        details=f"Password changed for user {current_user.username}"
    )

    return {"message": "Password has been changed successfully"}
